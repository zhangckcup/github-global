// ç¿»è¯‘å¼•æ“æ ¸å¿ƒæ¨¡å—

import { prisma } from '@/lib/db';
import { getInstallationOctokit, getUserOctokit } from '@/lib/github/client';
import { 
  getFileTree, 
  createBranch, 
  createOrUpdateFile, 
  createPullRequest,
  getFileContent,
  getFileContentWithSha,
  getFileSha,
  fileExists
} from '@/lib/github/operations';
import { translateWithFallback } from '@/lib/openrouter/fallback';
import { insertLanguageLinks } from '@/lib/translation/readme-updater';
import { getTranslatedPath } from '@/lib/translation/filename-translator';
import { decrypt } from '@/lib/crypto';
import { TranslationStatus, FileStatus } from '@prisma/client';
import { FileTreeNode } from '@/types';
import { Octokit } from 'octokit';

export interface TranslationOptions {
  taskId: string;
  userId: string;
  repositoryId: string;
  targetLanguages: string[];
}

export interface IncrementalTranslationOptions extends TranslationOptions {
  type: 'INCREMENTAL';
  changedFiles: string[];  // å˜æ›´çš„æ–‡ä»¶åˆ—è¡¨
}

/**
 * è·å–ç”¨æˆ·çš„ API Key å’Œé»˜è®¤æ¨¡å‹ï¼ˆä¼˜å…ˆç”¨æˆ·è‡ªå¸¦ï¼Œå¦åˆ™ä½¿ç”¨å¹³å°æ‰˜ç®¡ï¼‰
 */
async function getApiKeyAndModelForUser(userId: string): Promise<{ apiKey: string; defaultModel: string | null }> {
  // 1. ä¼˜å…ˆæŸ¥æ‰¾ç”¨æˆ·è‡ªå¸¦çš„ API Key
  const userApiKey = await prisma.apiKey.findFirst({
    where: { userId, provider: 'openrouter', isActive: true },
    select: {
      encryptedKey: true,
      defaultModel: true,
    },
  });

  if (userApiKey) {
    return {
      apiKey: decrypt(userApiKey.encryptedKey),
      defaultModel: userApiKey.defaultModel,
    };
  }

  // 2. ä½¿ç”¨å¹³å°æ‰˜ç®¡çš„ API Key
  const platformApiKey = process.env.PLATFORM_OPENROUTER_API_KEY;

  if (!platformApiKey) {
    throw new Error('No API key available. Please add your OpenRouter API key in settings.');
  }

  return {
    apiKey: platformApiKey,
    defaultModel: null,
  };
}

/**
 * è·å–ç”¨æˆ·çš„ API Keyï¼ˆä¼˜å…ˆç”¨æˆ·è‡ªå¸¦ï¼Œå¦åˆ™ä½¿ç”¨å¹³å°æ‰˜ç®¡ï¼‰
 * @deprecated ä½¿ç”¨ getApiKeyAndModelForUser ä»£æ›¿
 */
async function getApiKeyForUser(userId: string): Promise<string> {
  const { apiKey } = await getApiKeyAndModelForUser(userId);
  return apiKey;
}

/**
 * è·å–å¾…ç¿»è¯‘çš„æ–‡ä»¶åˆ—è¡¨
 */
async function getFilesToTranslate(
  fileTree: FileTreeNode[],
  includePaths?: string[],
  excludePaths?: string[]
): Promise<string[]> {
  const files: string[] = [];

  function traverse(nodes: FileTreeNode[]) {
    for (const node of nodes) {
      if (node.type === 'file' && node.isMarkdown) {
        // æ£€æŸ¥æ˜¯å¦åœ¨æ’é™¤è·¯å¾„ä¸­
        if (excludePaths?.some(pattern => matchPath(node.path, pattern))) {
          continue;
        }

        // å¦‚æœæŒ‡å®šäº†åŒ…å«è·¯å¾„ï¼Œæ£€æŸ¥æ˜¯å¦åŒ¹é…
        if (includePaths && includePaths.length > 0) {
          if (includePaths.some(pattern => matchPath(node.path, pattern))) {
            files.push(node.path);
          }
        } else {
          files.push(node.path);
        }
      }

      if (node.children) {
        traverse(node.children);
      }
    }
  }

  traverse(fileTree);
  return files;
}

/**
 * ç®€å•çš„è·¯å¾„åŒ¹é…ï¼ˆæ”¯æŒ ** å’Œ * é€šé…ç¬¦ï¼‰
 */
function matchPath(path: string, pattern: string): boolean {
  // å°† ** æ›¿æ¢ä¸º .*ï¼Œå°† * æ›¿æ¢ä¸º [^/]*
  const regexPattern = pattern
    .replace(/\*\*/g, '.*')
    .replace(/\*/g, '[^/]*')
    .replace(/\./g, '\\.');
  
  const regex = new RegExp(`^${regexPattern}$`);
  return regex.test(path);
}

/**
 * æ„å»º PR æè¿°
 */
function buildPRDescription(
  targetLanguages: string[],
  completedFiles: number,
  failedFiles: number
): string {
  return `## ğŸŒ Translation Summary

This PR adds translations for the following languages:
${targetLanguages.map(lang => `- ${lang}`).join('\n')}

### Statistics
- âœ… Completed: ${completedFiles} files
- âŒ Failed: ${failedFiles} files

---

*Generated by [GitHub Global](https://github.com/your-org/github-global)*
`;
}

/**
 * æ‰§è¡Œç¿»è¯‘ä»»åŠ¡
 */
export async function executeTranslation(options: TranslationOptions): Promise<{ success: boolean; prUrl?: string }> {
  const { taskId, userId, repositoryId, targetLanguages } = options;

  console.log(`[Translation] Starting task ${taskId}`);

  // æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºè¿è¡Œä¸­
  await prisma.translationTask.update({
    where: { id: taskId },
    data: {
      status: TranslationStatus.RUNNING,
      startedAt: new Date(),
    },
  });

  try {
    // 1. è·å–ä»“åº“ä¿¡æ¯å’Œé…ç½®
    const repository = await prisma.repository.findUnique({
      where: { id: repositoryId },
      include: { config: true, user: true },
    });

    if (!repository) {
      throw new Error('Repository not found');
    }

    console.log(`[Translation] Repository: ${repository.fullName}`);

    // 2. è·å–ç”¨æˆ·çš„ API Key å’Œé»˜è®¤æ¨¡å‹
    const { apiKey, defaultModel: userDefaultModel } = await getApiKeyAndModelForUser(userId);

    // 3. è·å– GitHub Octokit å®¢æˆ·ç«¯
    let octokit: Octokit;
    
    if (repository.user.installationId) {
      // ä¼˜å…ˆä½¿ç”¨ GitHub App Installation tokenï¼ˆæ¨èæ–¹å¼ï¼‰
      console.log('[Translation] Attempting to use GitHub App Installation ID:', repository.user.installationId);
      try {
        octokit = await getInstallationOctokit(repository.user.installationId);
        console.log('[Translation] Successfully authenticated with GitHub App');
      } catch (error) {
        console.error('[Translation] GitHub App authentication failed:', error);
        // Fallback åˆ°ç”¨æˆ· token
        if (repository.user.accessToken) {
          console.log('[Translation] Falling back to user access token');
          const accessToken = decrypt(repository.user.accessToken);
          octokit = getUserOctokit(accessToken);
        } else {
          throw error;
        }
      }
    } else if (repository.user.accessToken) {
      // ä½¿ç”¨ç”¨æˆ·çš„ OAuth access token
      console.log('[Translation] Using user access token');
      const accessToken = decrypt(repository.user.accessToken);
      octokit = getUserOctokit(accessToken);
    } else {
      throw new Error('No authentication method available. Please install the GitHub App.');
    }

    // 4. è·å–ä»“åº“æ–‡ä»¶æ ‘
    const fileTree = await getFileTree(
      octokit,
      repository.owner,
      repository.name
    );

    // 5. è·å–å¾…ç¿»è¯‘çš„æ–‡ä»¶åˆ—è¡¨
    const includePaths = repository.config?.includePaths as string[] | undefined;
    const excludePaths = repository.config?.excludePaths as string[] | undefined;
    const filesToTranslate = await getFilesToTranslate(fileTree, includePaths, excludePaths);

    console.log(`[Translation] Found ${filesToTranslate.length} files to translate`);

    // 6. æ›´æ–°ä»»åŠ¡æ€»æ–‡ä»¶æ•°
    const totalFiles = filesToTranslate.length * targetLanguages.length;
    await prisma.translationTask.update({
      where: { id: taskId },
      data: { totalFiles },
    });

    // 7. åˆ›å»ºç¿»è¯‘åˆ†æ”¯
    const branchName = `translations-${Date.now()}`;
    const baseBranch = repository.defaultBranch;
    
    console.log(`[Translation] Creating branch: ${branchName}`);
    await createBranch(octokit, repository.owner, repository.name, branchName, baseBranch);

    // 8. é€ä¸ªç¿»è¯‘æ–‡ä»¶
    let completedFiles = 0;
    let failedFiles = 0;
    const baseLanguage = repository.config?.baseLanguage || 'zh-CN';
    
    // æ¨¡å‹ä¼˜å…ˆçº§ï¼šä»“åº“é…ç½® > ç”¨æˆ·é»˜è®¤ > ç³»ç»Ÿé»˜è®¤ (undefined è¡¨ç¤ºä½¿ç”¨ fallback æœºåˆ¶)
    const repoAiModel = repository.config?.aiModel as string | undefined;
    const aiModel = repoAiModel || userDefaultModel || undefined;
    
    console.log(`[Translation] Using AI model: ${aiModel || 'default (fallback)'}`);
    if (repoAiModel) {
      console.log('[Translation] Model source: repository config');
    } else if (userDefaultModel) {
      console.log('[Translation] Model source: user default');
    } else {
      console.log('[Translation] Model source: system default (fallback)');
    }

    for (const filePath of filesToTranslate) {
      // è·å–æºæ–‡ä»¶å†…å®¹
      let sourceContent: string;
      try {
        sourceContent = await getFileContent(
          octokit,
          repository.owner,
          repository.name,
          filePath,
          baseBranch
        );
      } catch (error) {
        console.error(`[Translation] Failed to get file ${filePath}:`, error);
        continue;
      }

      for (const targetLang of targetLanguages) {
        try {
          // è®¡ç®—ç¿»è¯‘åçš„ç›®æ ‡è·¯å¾„ï¼ˆåŸºå‡†è¯­è¨€ä¿æŒåŸæ–‡ä»¶åï¼Œå…¶ä»–è¯­è¨€ç¿»è¯‘ä¸ºè‹±æ–‡ï¼‰
          const targetPath = getTranslatedPath(filePath, targetLang, baseLanguage);
          
          console.log(`[Translation] Translating ${filePath} to ${targetLang} -> ${targetPath}`);

          // åˆ›å»ºç¿»è¯‘æ–‡ä»¶è®°å½•
          const translatedFile = await prisma.translatedFile.create({
            data: {
              translationTaskId: taskId,
              sourcePath: filePath,
              targetPath,
              targetLanguage: targetLang,
              status: FileStatus.TRANSLATING,
              sourceContent,
            },
          });

          // è°ƒç”¨ AI ç¿»è¯‘
          const translatedContent = await translateWithFallback(
            sourceContent,
            baseLanguage,
            targetLang,
            apiKey,
            aiModel
          );

          // æ£€æŸ¥ç›®æ ‡æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨ï¼ˆå¯èƒ½æ˜¯ä¹‹å‰çš„ç¿»è¯‘ä»»åŠ¡åˆ›å»ºçš„ï¼‰
          // å¦‚æœå­˜åœ¨ï¼Œéœ€è¦è·å–å…¶ SHA æ‰èƒ½æ›´æ–°
          const existingSha = await getFileSha(
            octokit,
            repository.owner,
            repository.name,
            targetPath,
            branchName
          );

          // å†™å…¥ GitHubï¼ˆä½¿ç”¨ç¿»è¯‘åçš„ç›®æ ‡è·¯å¾„ï¼‰
          await createOrUpdateFile(
            octokit,
            repository.owner,
            repository.name,
            targetPath,
            translatedContent,
            `[GitHub Global] Translate ${filePath} to ${targetLang}`,
            branchName,
            existingSha || undefined  // å¦‚æœæ–‡ä»¶å·²å­˜åœ¨ï¼Œä¼ é€’ SHAï¼›å¦åˆ™ä¸ä¼ 
          );

          // æ›´æ–°æ–‡ä»¶çŠ¶æ€
          await prisma.translatedFile.update({
            where: { id: translatedFile.id },
            data: {
              status: FileStatus.COMPLETED,
              translatedContent,
            },
          });

          completedFiles++;
          console.log(`[Translation] âœ“ Completed ${filePath} -> ${targetLang}`);
        } catch (error) {
          console.error(`[Translation] âœ— Failed to translate ${filePath} to ${targetLang}:`, error);
          failedFiles++;

          await prisma.translatedFile.updateMany({
            where: {
              translationTaskId: taskId,
              sourcePath: filePath,
              targetLanguage: targetLang,
            },
            data: {
              status: FileStatus.FAILED,
              errorMessage: (error as Error).message,
            },
          });
        }

        // æ›´æ–°è¿›åº¦
        const progress = ((completedFiles + failedFiles) / totalFiles) * 100;
        await prisma.translationTask.update({
          where: { id: taskId },
          data: { completedFiles, failedFiles, progress },
        });
      }
    }

    // 9. æ›´æ–° README å¤šè¯­è¨€é“¾æ¥ï¼ˆå¦‚æœ README.md å­˜åœ¨ï¼‰
    const readmePath = 'README.md';
    const hasReadme = await fileExists(
      octokit,
      repository.owner,
      repository.name,
      readmePath,
      baseBranch
    );

    if (hasReadme) {
      try {
        console.log('[Translation] Updating README with language links');
        
        // è·å– README å†…å®¹å’Œ SHAï¼ˆä»åŸºå‡†åˆ†æ”¯ï¼‰
        const readmeInfo = await getFileContentWithSha(
          octokit,
          repository.owner,
          repository.name,
          readmePath,
          baseBranch
        );

        const updatedReadme = insertLanguageLinks(readmeInfo.content, targetLanguages);

        // æ£€æŸ¥ç¿»è¯‘åˆ†æ”¯ä¸Šæ˜¯å¦å·²æœ‰ READMEï¼ˆå¯èƒ½ä¹‹å‰çš„æ“ä½œå·²åˆ›å»ºï¼‰
        // å¦‚æœæœ‰ï¼Œä½¿ç”¨ç¿»è¯‘åˆ†æ”¯ä¸Šçš„ SHAï¼›å¦åˆ™ä½¿ç”¨åŸºå‡†åˆ†æ”¯çš„ SHA
        let readmeSha = readmeInfo.sha;
        const branchReadmeSha = await getFileSha(
          octokit,
          repository.owner,
          repository.name,
          readmePath,
          branchName
        );
        if (branchReadmeSha) {
          readmeSha = branchReadmeSha;
        }

        await createOrUpdateFile(
          octokit,
          repository.owner,
          repository.name,
          readmePath,
          updatedReadme,
          '[GitHub Global] Add language switcher to README',
          branchName,
          readmeSha
        );
        
        console.log('[Translation] README updated successfully');
      } catch (error) {
        console.error('[Translation] Failed to update README:', error);
      }
    }

    // 10. åˆ›å»º Pull Request
    console.log('[Translation] Creating Pull Request');
    const pr = await createPullRequest(
      octokit,
      repository.owner,
      repository.name,
      `[GitHub Global] Add translations for ${targetLanguages.join(', ')}`,
      buildPRDescription(targetLanguages, completedFiles, failedFiles),
      branchName,
      baseBranch
    );

    console.log(`[Translation] âœ“ Pull Request created: ${pr.html_url}`);

    // 11. æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºå®Œæˆ
    await prisma.translationTask.update({
      where: { id: taskId },
      data: {
        status: TranslationStatus.COMPLETED,
        completedAt: new Date(),
        pullRequestUrl: pr.html_url,
        pullRequestNumber: pr.number,
      },
    });

    return { success: true, prUrl: pr.html_url };
  } catch (error) {
    console.error(`[Translation] Task ${taskId} failed:`, error);

    // æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºå¤±è´¥
    await prisma.translationTask.update({
      where: { id: taskId },
      data: {
        status: TranslationStatus.FAILED,
        completedAt: new Date(),
        errorMessage: (error as Error).message,
      },
    });

    throw error;
  }
}

/**
 * ç”Ÿæˆæ¸…æ™°çš„æ—¶é—´æ ¼å¼åˆ†æ”¯å
 * æ ¼å¼: translations-YYYYMMDD-HHmmss
 */
function generateBranchName(): string {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  const seconds = String(now.getSeconds()).padStart(2, '0');
  
  return `translations-${year}${month}${day}-${hours}${minutes}${seconds}`;
}

/**
 * æ„å»ºå¢é‡ç¿»è¯‘çš„ PR æè¿°
 */
function buildIncrementalPRDescription(
  targetLanguages: string[],
  changedFiles: string[],
  completedFiles: number,
  failedFiles: number
): string {
  return `## ğŸŒ Auto Translation (Incremental)

This PR was automatically triggered by changes to the following files:
${changedFiles.map(file => `- \`${file}\``).join('\n')}

### Target Languages
${targetLanguages.map(lang => `- ${lang}`).join('\n')}

### Statistics
- âœ… Completed: ${completedFiles} files
- âŒ Failed: ${failedFiles} files

---

*Auto-generated by [GitHub Global](https://github.com/your-org/github-global)*
`;
}

/**
 * æ‰§è¡Œå¢é‡ç¿»è¯‘ä»»åŠ¡ï¼ˆä»…ç¿»è¯‘æŒ‡å®šçš„å˜æ›´æ–‡ä»¶ï¼‰
 */
export async function executeIncrementalTranslation(
  options: IncrementalTranslationOptions
): Promise<{ success: boolean; prUrl?: string }> {
  const { taskId, userId, repositoryId, targetLanguages, changedFiles } = options;

  console.log(`[Translation] Starting incremental task ${taskId}`);
  console.log(`[Translation] Changed files: ${changedFiles.join(', ')}`);

  // æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºè¿è¡Œä¸­
  await prisma.translationTask.update({
    where: { id: taskId },
    data: {
      status: TranslationStatus.RUNNING,
      startedAt: new Date(),
    },
  });

  try {
    // 1. è·å–ä»“åº“ä¿¡æ¯å’Œé…ç½®
    const repository = await prisma.repository.findUnique({
      where: { id: repositoryId },
      include: { config: true, user: true },
    });

    if (!repository) {
      throw new Error('Repository not found');
    }

    console.log(`[Translation] Repository: ${repository.fullName}`);

    // 2. è·å–ç”¨æˆ·çš„ API Key å’Œé»˜è®¤æ¨¡å‹
    const { apiKey, defaultModel: userDefaultModel } = await getApiKeyAndModelForUser(userId);

    // 3. è·å– GitHub Octokit å®¢æˆ·ç«¯
    let octokit: Octokit;
    
    if (repository.user.installationId) {
      console.log('[Translation] Using GitHub App Installation ID:', repository.user.installationId);
      try {
        octokit = await getInstallationOctokit(repository.user.installationId);
        console.log('[Translation] Successfully authenticated with GitHub App');
      } catch (error) {
        console.error('[Translation] GitHub App authentication failed:', error);
        if (repository.user.accessToken) {
          console.log('[Translation] Falling back to user access token');
          const accessToken = decrypt(repository.user.accessToken);
          octokit = getUserOctokit(accessToken);
        } else {
          throw error;
        }
      }
    } else if (repository.user.accessToken) {
      console.log('[Translation] Using user access token');
      const accessToken = decrypt(repository.user.accessToken);
      octokit = getUserOctokit(accessToken);
    } else {
      throw new Error('No authentication method available. Please install the GitHub App.');
    }

    // 4. ä½¿ç”¨ä¼ å…¥çš„å˜æ›´æ–‡ä»¶åˆ—è¡¨ï¼ˆå·²ç»è¿‡ Webhook ç­›é€‰ï¼‰
    const filesToTranslate = changedFiles;
    console.log(`[Translation] Files to translate: ${filesToTranslate.length}`);

    if (filesToTranslate.length === 0) {
      console.log('[Translation] No files to translate');
      await prisma.translationTask.update({
        where: { id: taskId },
        data: {
          status: TranslationStatus.COMPLETED,
          completedAt: new Date(),
        },
      });
      return { success: true };
    }

    // 5. æ›´æ–°ä»»åŠ¡æ€»æ–‡ä»¶æ•°
    const totalFiles = filesToTranslate.length * targetLanguages.length;
    await prisma.translationTask.update({
      where: { id: taskId },
      data: { totalFiles },
    });

    // 6. åˆ›å»ºç¿»è¯‘åˆ†æ”¯ï¼ˆä½¿ç”¨æ¸…æ™°çš„æ—¶é—´æ ¼å¼ï¼‰
    const branchName = generateBranchName();
    const baseBranch = repository.defaultBranch;
    
    console.log(`[Translation] Creating branch: ${branchName}`);
    await createBranch(octokit, repository.owner, repository.name, branchName, baseBranch);

    // 7. é€ä¸ªç¿»è¯‘æ–‡ä»¶
    let completedFiles = 0;
    let failedFiles = 0;
    const baseLanguage = repository.config?.baseLanguage || 'zh-CN';
    
    // æ¨¡å‹ä¼˜å…ˆçº§ï¼šä»“åº“é…ç½® > ç”¨æˆ·é»˜è®¤ > ç³»ç»Ÿé»˜è®¤
    const repoAiModel = repository.config?.aiModel as string | undefined;
    const aiModel = repoAiModel || userDefaultModel || undefined;
    
    console.log(`[Translation] Using AI model: ${aiModel || 'default (fallback)'}`);

    for (const filePath of filesToTranslate) {
      // è·å–æºæ–‡ä»¶å†…å®¹
      let sourceContent: string;
      try {
        sourceContent = await getFileContent(
          octokit,
          repository.owner,
          repository.name,
          filePath,
          baseBranch
        );
      } catch (error) {
        console.error(`[Translation] Failed to get file ${filePath}:`, error);
        continue;
      }

      for (const targetLang of targetLanguages) {
        try {
          const targetPath = getTranslatedPath(filePath, targetLang, baseLanguage);
          
          console.log(`[Translation] Translating ${filePath} to ${targetLang} -> ${targetPath}`);

          // åˆ›å»ºç¿»è¯‘æ–‡ä»¶è®°å½•
          const translatedFile = await prisma.translatedFile.create({
            data: {
              translationTaskId: taskId,
              sourcePath: filePath,
              targetPath,
              targetLanguage: targetLang,
              status: FileStatus.TRANSLATING,
              sourceContent,
            },
          });

          // è°ƒç”¨ AI ç¿»è¯‘
          const translatedContent = await translateWithFallback(
            sourceContent,
            baseLanguage,
            targetLang,
            apiKey,
            aiModel
          );

          // æ£€æŸ¥ç›®æ ‡æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
          const existingSha = await getFileSha(
            octokit,
            repository.owner,
            repository.name,
            targetPath,
            branchName
          );

          // å†™å…¥ GitHub
          await createOrUpdateFile(
            octokit,
            repository.owner,
            repository.name,
            targetPath,
            translatedContent,
            `[GitHub Global] Translate ${filePath} to ${targetLang}`,
            branchName,
            existingSha || undefined
          );

          // æ›´æ–°æ–‡ä»¶çŠ¶æ€
          await prisma.translatedFile.update({
            where: { id: translatedFile.id },
            data: {
              status: FileStatus.COMPLETED,
              translatedContent,
            },
          });

          completedFiles++;
          console.log(`[Translation] âœ“ Completed ${filePath} -> ${targetLang}`);
        } catch (error) {
          console.error(`[Translation] âœ— Failed to translate ${filePath} to ${targetLang}:`, error);
          failedFiles++;

          await prisma.translatedFile.updateMany({
            where: {
              translationTaskId: taskId,
              sourcePath: filePath,
              targetLanguage: targetLang,
            },
            data: {
              status: FileStatus.FAILED,
              errorMessage: (error as Error).message,
            },
          });
        }

        // æ›´æ–°è¿›åº¦
        const progress = ((completedFiles + failedFiles) / totalFiles) * 100;
        await prisma.translationTask.update({
          where: { id: taskId },
          data: { completedFiles, failedFiles, progress },
        });
      }
    }

    // 8. åˆ›å»º Pull Request
    console.log('[Translation] Creating Pull Request');
    const pr = await createPullRequest(
      octokit,
      repository.owner,
      repository.name,
      `[GitHub Global] Auto-translate ${changedFiles.length} changed file(s)`,
      buildIncrementalPRDescription(targetLanguages, changedFiles, completedFiles, failedFiles),
      branchName,
      baseBranch
    );

    console.log(`[Translation] âœ“ Pull Request created: ${pr.html_url}`);

    // 9. æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºå®Œæˆ
    await prisma.translationTask.update({
      where: { id: taskId },
      data: {
        status: TranslationStatus.COMPLETED,
        completedAt: new Date(),
        pullRequestUrl: pr.html_url,
        pullRequestNumber: pr.number,
      },
    });

    return { success: true, prUrl: pr.html_url };
  } catch (error) {
    console.error(`[Translation] Incremental task ${taskId} failed:`, error);

    await prisma.translationTask.update({
      where: { id: taskId },
      data: {
        status: TranslationStatus.FAILED,
        completedAt: new Date(),
        errorMessage: (error as Error).message,
      },
    });

    throw error;
  }
}
