// ç¿»è¯‘å¼•æ“æ ¸å¿ƒæ¨¡å—

import { prisma } from '@/lib/db';
import { getInstallationOctokit, getUserOctokit } from '@/lib/github/client';
import { 
  getFileTree, 
  createBranch, 
  createOrUpdateFile, 
  createPullRequest,
  getFileContent,
  getFileContentWithSha,
  getFileSha,
  fileExists
} from '@/lib/github/operations';
import { translateWithFallback } from '@/lib/openrouter/fallback';
import { insertLanguageLinks } from '@/lib/translation/readme-updater';
import { getTranslatedPath } from '@/lib/translation/filename-translator';
import { decrypt } from '@/lib/crypto';
import { TranslationStatus, FileStatus } from '@prisma/client';
import { FileTreeNode } from '@/types';
import { Octokit } from 'octokit';

export interface TranslationOptions {
  taskId: string;
  userId: string;
  repositoryId: string;
  targetLanguages: string[];
}

/**
 * è·å–ç”¨æˆ·çš„ API Keyï¼ˆä¼˜å…ˆç”¨æˆ·è‡ªå¸¦ï¼Œå¦åˆ™ä½¿ç”¨å¹³å°æ‰˜ç®¡ï¼‰
 */
async function getApiKeyForUser(userId: string): Promise<string> {
  // 1. ä¼˜å…ˆæŸ¥æ‰¾ç”¨æˆ·è‡ªå¸¦çš„ API Key
  const userApiKey = await prisma.apiKey.findFirst({
    where: { userId, provider: 'openrouter', isActive: true },
  });

  if (userApiKey) {
    return decrypt(userApiKey.encryptedKey);
  }

  // 2. ä½¿ç”¨å¹³å°æ‰˜ç®¡çš„ API Key
  const platformApiKey = process.env.PLATFORM_OPENROUTER_API_KEY;

  if (!platformApiKey) {
    throw new Error('No API key available. Please add your OpenRouter API key in settings.');
  }

  return platformApiKey;
}

/**
 * è·å–å¾…ç¿»è¯‘çš„æ–‡ä»¶åˆ—è¡¨
 */
async function getFilesToTranslate(
  fileTree: FileTreeNode[],
  includePaths?: string[],
  excludePaths?: string[]
): Promise<string[]> {
  const files: string[] = [];

  function traverse(nodes: FileTreeNode[]) {
    for (const node of nodes) {
      if (node.type === 'file' && node.isMarkdown) {
        // æ£€æŸ¥æ˜¯å¦åœ¨æ’é™¤è·¯å¾„ä¸­
        if (excludePaths?.some(pattern => matchPath(node.path, pattern))) {
          continue;
        }

        // å¦‚æœæŒ‡å®šäº†åŒ…å«è·¯å¾„ï¼Œæ£€æŸ¥æ˜¯å¦åŒ¹é…
        if (includePaths && includePaths.length > 0) {
          if (includePaths.some(pattern => matchPath(node.path, pattern))) {
            files.push(node.path);
          }
        } else {
          files.push(node.path);
        }
      }

      if (node.children) {
        traverse(node.children);
      }
    }
  }

  traverse(fileTree);
  return files;
}

/**
 * ç®€å•çš„è·¯å¾„åŒ¹é…ï¼ˆæ”¯æŒ ** å’Œ * é€šé…ç¬¦ï¼‰
 */
function matchPath(path: string, pattern: string): boolean {
  // å°† ** æ›¿æ¢ä¸º .*ï¼Œå°† * æ›¿æ¢ä¸º [^/]*
  const regexPattern = pattern
    .replace(/\*\*/g, '.*')
    .replace(/\*/g, '[^/]*')
    .replace(/\./g, '\\.');
  
  const regex = new RegExp(`^${regexPattern}$`);
  return regex.test(path);
}

/**
 * æ„å»º PR æè¿°
 */
function buildPRDescription(
  targetLanguages: string[],
  completedFiles: number,
  failedFiles: number
): string {
  return `## ğŸŒ Translation Summary

This PR adds translations for the following languages:
${targetLanguages.map(lang => `- ${lang}`).join('\n')}

### Statistics
- âœ… Completed: ${completedFiles} files
- âŒ Failed: ${failedFiles} files

---

*Generated by [GitHub Global](https://github.com/your-org/github-global)*
`;
}

/**
 * æ‰§è¡Œç¿»è¯‘ä»»åŠ¡
 */
export async function executeTranslation(options: TranslationOptions): Promise<{ success: boolean; prUrl?: string }> {
  const { taskId, userId, repositoryId, targetLanguages } = options;

  console.log(`[Translation] Starting task ${taskId}`);

  // æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºè¿è¡Œä¸­
  await prisma.translationTask.update({
    where: { id: taskId },
    data: {
      status: TranslationStatus.RUNNING,
      startedAt: new Date(),
    },
  });

  try {
    // 1. è·å–ä»“åº“ä¿¡æ¯å’Œé…ç½®
    const repository = await prisma.repository.findUnique({
      where: { id: repositoryId },
      include: { config: true, user: true },
    });

    if (!repository) {
      throw new Error('Repository not found');
    }

    console.log(`[Translation] Repository: ${repository.fullName}`);

    // 2. è·å–ç”¨æˆ·çš„ API Key
    const apiKey = await getApiKeyForUser(userId);

    // 3. è·å– GitHub Octokit å®¢æˆ·ç«¯
    let octokit: Octokit;
    
    if (repository.user.installationId) {
      // ä¼˜å…ˆä½¿ç”¨ GitHub App Installation tokenï¼ˆæ¨èæ–¹å¼ï¼‰
      console.log('[Translation] Attempting to use GitHub App Installation ID:', repository.user.installationId);
      try {
        octokit = await getInstallationOctokit(repository.user.installationId);
        console.log('[Translation] Successfully authenticated with GitHub App');
      } catch (error) {
        console.error('[Translation] GitHub App authentication failed:', error);
        // Fallback åˆ°ç”¨æˆ· token
        if (repository.user.accessToken) {
          console.log('[Translation] Falling back to user access token');
          const accessToken = decrypt(repository.user.accessToken);
          octokit = getUserOctokit(accessToken);
        } else {
          throw error;
        }
      }
    } else if (repository.user.accessToken) {
      // ä½¿ç”¨ç”¨æˆ·çš„ OAuth access token
      console.log('[Translation] Using user access token');
      const accessToken = decrypt(repository.user.accessToken);
      octokit = getUserOctokit(accessToken);
    } else {
      throw new Error('No authentication method available. Please install the GitHub App.');
    }

    // 4. è·å–ä»“åº“æ–‡ä»¶æ ‘
    const fileTree = await getFileTree(
      octokit,
      repository.owner,
      repository.name
    );

    // 5. è·å–å¾…ç¿»è¯‘çš„æ–‡ä»¶åˆ—è¡¨
    const includePaths = repository.config?.includePaths as string[] | undefined;
    const excludePaths = repository.config?.excludePaths as string[] | undefined;
    const filesToTranslate = await getFilesToTranslate(fileTree, includePaths, excludePaths);

    console.log(`[Translation] Found ${filesToTranslate.length} files to translate`);

    // 6. æ›´æ–°ä»»åŠ¡æ€»æ–‡ä»¶æ•°
    const totalFiles = filesToTranslate.length * targetLanguages.length;
    await prisma.translationTask.update({
      where: { id: taskId },
      data: { totalFiles },
    });

    // 7. åˆ›å»ºç¿»è¯‘åˆ†æ”¯
    const branchName = `translations-${Date.now()}`;
    const baseBranch = repository.defaultBranch;
    
    console.log(`[Translation] Creating branch: ${branchName}`);
    await createBranch(octokit, repository.owner, repository.name, branchName, baseBranch);

    // 8. é€ä¸ªç¿»è¯‘æ–‡ä»¶
    let completedFiles = 0;
    let failedFiles = 0;
    const baseLanguage = repository.config?.baseLanguage || 'zh-CN';
    const aiModel = repository.config?.aiModel as string | undefined;

    for (const filePath of filesToTranslate) {
      // è·å–æºæ–‡ä»¶å†…å®¹
      let sourceContent: string;
      try {
        sourceContent = await getFileContent(
          octokit,
          repository.owner,
          repository.name,
          filePath,
          baseBranch
        );
      } catch (error) {
        console.error(`[Translation] Failed to get file ${filePath}:`, error);
        continue;
      }

      for (const targetLang of targetLanguages) {
        try {
          // è®¡ç®—ç¿»è¯‘åçš„ç›®æ ‡è·¯å¾„ï¼ˆåŸºå‡†è¯­è¨€ä¿æŒåŸæ–‡ä»¶åï¼Œå…¶ä»–è¯­è¨€ç¿»è¯‘ä¸ºè‹±æ–‡ï¼‰
          const targetPath = getTranslatedPath(filePath, targetLang, baseLanguage);
          
          console.log(`[Translation] Translating ${filePath} to ${targetLang} -> ${targetPath}`);

          // åˆ›å»ºç¿»è¯‘æ–‡ä»¶è®°å½•
          const translatedFile = await prisma.translatedFile.create({
            data: {
              translationTaskId: taskId,
              sourcePath: filePath,
              targetPath,
              targetLanguage: targetLang,
              status: FileStatus.TRANSLATING,
              sourceContent,
            },
          });

          // è°ƒç”¨ AI ç¿»è¯‘
          const translatedContent = await translateWithFallback(
            sourceContent,
            baseLanguage,
            targetLang,
            apiKey,
            aiModel
          );

          // å†™å…¥ GitHubï¼ˆä½¿ç”¨ç¿»è¯‘åçš„ç›®æ ‡è·¯å¾„ï¼‰
          await createOrUpdateFile(
            octokit,
            repository.owner,
            repository.name,
            targetPath,
            translatedContent,
            `[GitHub Global] Translate ${filePath} to ${targetLang}`,
            branchName
          );

          // æ›´æ–°æ–‡ä»¶çŠ¶æ€
          await prisma.translatedFile.update({
            where: { id: translatedFile.id },
            data: {
              status: FileStatus.COMPLETED,
              translatedContent,
            },
          });

          completedFiles++;
          console.log(`[Translation] âœ“ Completed ${filePath} -> ${targetLang}`);
        } catch (error) {
          console.error(`[Translation] âœ— Failed to translate ${filePath} to ${targetLang}:`, error);
          failedFiles++;

          await prisma.translatedFile.updateMany({
            where: {
              translationTaskId: taskId,
              sourcePath: filePath,
              targetLanguage: targetLang,
            },
            data: {
              status: FileStatus.FAILED,
              errorMessage: (error as Error).message,
            },
          });
        }

        // æ›´æ–°è¿›åº¦
        const progress = ((completedFiles + failedFiles) / totalFiles) * 100;
        await prisma.translationTask.update({
          where: { id: taskId },
          data: { completedFiles, failedFiles, progress },
        });
      }
    }

    // 9. æ›´æ–° README å¤šè¯­è¨€é“¾æ¥ï¼ˆå¦‚æœ README.md å­˜åœ¨ï¼‰
    const readmePath = 'README.md';
    const hasReadme = await fileExists(
      octokit,
      repository.owner,
      repository.name,
      readmePath,
      baseBranch
    );

    if (hasReadme) {
      try {
        console.log('[Translation] Updating README with language links');
        
        // è·å– README å†…å®¹å’Œ SHAï¼ˆä»åŸºå‡†åˆ†æ”¯ï¼‰
        const readmeInfo = await getFileContentWithSha(
          octokit,
          repository.owner,
          repository.name,
          readmePath,
          baseBranch
        );

        const updatedReadme = insertLanguageLinks(readmeInfo.content, targetLanguages);

        // æ£€æŸ¥ç¿»è¯‘åˆ†æ”¯ä¸Šæ˜¯å¦å·²æœ‰ READMEï¼ˆå¯èƒ½ä¹‹å‰çš„æ“ä½œå·²åˆ›å»ºï¼‰
        // å¦‚æœæœ‰ï¼Œä½¿ç”¨ç¿»è¯‘åˆ†æ”¯ä¸Šçš„ SHAï¼›å¦åˆ™ä½¿ç”¨åŸºå‡†åˆ†æ”¯çš„ SHA
        let readmeSha = readmeInfo.sha;
        const branchReadmeSha = await getFileSha(
          octokit,
          repository.owner,
          repository.name,
          readmePath,
          branchName
        );
        if (branchReadmeSha) {
          readmeSha = branchReadmeSha;
        }

        await createOrUpdateFile(
          octokit,
          repository.owner,
          repository.name,
          readmePath,
          updatedReadme,
          '[GitHub Global] Add language switcher to README',
          branchName,
          readmeSha
        );
        
        console.log('[Translation] README updated successfully');
      } catch (error) {
        console.error('[Translation] Failed to update README:', error);
      }
    }

    // 10. åˆ›å»º Pull Request
    console.log('[Translation] Creating Pull Request');
    const pr = await createPullRequest(
      octokit,
      repository.owner,
      repository.name,
      `[GitHub Global] Add translations for ${targetLanguages.join(', ')}`,
      buildPRDescription(targetLanguages, completedFiles, failedFiles),
      branchName,
      baseBranch
    );

    console.log(`[Translation] âœ“ Pull Request created: ${pr.html_url}`);

    // 11. æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºå®Œæˆ
    await prisma.translationTask.update({
      where: { id: taskId },
      data: {
        status: TranslationStatus.COMPLETED,
        completedAt: new Date(),
        pullRequestUrl: pr.html_url,
        pullRequestNumber: pr.number,
      },
    });

    return { success: true, prUrl: pr.html_url };
  } catch (error) {
    console.error(`[Translation] Task ${taskId} failed:`, error);

    // æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºå¤±è´¥
    await prisma.translationTask.update({
      where: { id: taskId },
      data: {
        status: TranslationStatus.FAILED,
        completedAt: new Date(),
        errorMessage: (error as Error).message,
      },
    });

    throw error;
  }
}
